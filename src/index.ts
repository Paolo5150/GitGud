import { app, BrowserWindow, Menu, ipcMain, dialog } from 'electron';
import { ChangeDir,  GitAddAllChanges, GitAddAllUntrackedFiles, GitBranchList, GitBranchName, GitChangeList,  GitCheckoutBranch,  GitCheckoutTrackBranch,  GitCommitCount,  GitCommitStaged, GitCreateBranch, GitDeleteAllUntrackedFiles, GitDeleteLocalBranch, GitDeleteUntrackedFile, GitDiffFile, GitDiscardAllChanges, GitDiscardFileChanges, GitFetch, GitIsRepoValid, GitLaunchDifftoolOnOfile, GitLog, GitMergeBranch, GitPull, GitPushBranch, GitSetOrigin, GitStagedList, GitStageFile, GitStatus, GitStatusSB, GitTopLevel, GitUnstageFile, GitUntrackedFiles, OpenRepoInExplorer, ReadFile, ResetBaseBranch, SetBaseBranch } from './gitcmds';
import { FSWatcher } from 'chokidar';
import { OpenBranchesDialog, OpenBranchNameDialog, OpenCommitDialog, OpenSetOriginDialog } from './SideWindows';
const chokidar = require('chokidar');

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;


var gitLogEntriesCount = 0;
var gitLogEntriesRequested = 0;
const gitLogCommitsToRenderEachTime = 20;

var checkFilesTimeout: string | number | NodeJS.Timeout = null;
var filesHaveChanged = false
var isValidRepo: Boolean = false;
var mainWindow: Electron.BrowserWindow;
// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

var chokiWathcer: FSWatcher;

const CreateMenu = ()=>{

  const menu = Menu.buildFromTemplate([
    {
    label: 'File',
    submenu: [
      {
        label: 'Open Repo',
        click: (menuItem, browserWin) => {

          openFolderPicker();

        }
      }]
    },
     // Conditionally add the Git menu
     ...(isValidRepo
      ? [
          {
            label: 'Branch',
            submenu: [
              {
                label: 'Branches',
                click: ()=>{OpenBranchesDialog(MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY); console.log('preload ' + MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY)}
        
              },
              
              {
                label: 'Create New',
                click: async ()=>{
                  ResetBaseBranch()
                  OpenBranchNameDialog(MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY)
                }
              },
              {
                label: 'Push to remote',
                click: async ()=>{
                  try
                  {
                    mainWindow.webContents.send('log',"Pushing to remote...", 'i')
                    var res = await GitBranchName()
                    await GitPushBranch(res)
                    mainWindow.webContents.send('log',"-- Branch pushed successfully", 'i')
                    Refresh();
                  }
                  catch(err)  { mainWindow.webContents.send('log',"Error while pushing" + err, 'e') }
                  
                }
              },
              {
                label: 'Pull from remote',
                click: async ()=>{
                  try
                  {
                    mainWindow.webContents.send('log',"Pulling from remote...", 'i')
                    await GitPull()
                    mainWindow.webContents.send('log',"-- Branch pulled successfully", 'i')
                    Refresh();

                  }
                  catch(err)  { mainWindow.webContents.send('log',"Error while pulling" + err, 'e') }
                }
              } 
            ],
          },
          {
            label: 'Repo',
            submenu: [
              {
                label: 'Fetch',
                click: async ()=>{
                  mainWindow.webContents.send('log',"Fetching...", 'i')
                  await GitFetch();
                  Refresh();
                  mainWindow.webContents.send('log',"-- Fetched", 'i')

                }
              },
              {
                label: 'Set Remote Address',
                click: ()=>{OpenSetOriginDialog(MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY)}
              }, 
              {
                label: 'Open In Explorer',
                click: ()=>{ OpenRepoInExplorer()}
              }
            ]
          }
        ]
      : []),
  
  ]);

  Menu.setApplicationMenu(menu)
}

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  //mainWindow.webContents.openDevTools();
  mainWindow.setMenu(null);

  CreateMenu();
};

async function RefreshCommitList()
{
  console.log('----- RefreshCommitList -----')
  //Update commit count
  var commitsCount = await GitCommitCount()
  gitLogEntriesCount = parseInt(commitsCount);
  gitLogEntriesRequested = 0;
  console.log('commits ' + gitLogEntriesCount)

  mainWindow.webContents.send('update-log-list', 'clear')
  console.log('requesting commits ' + gitLogCommitsToRenderEachTime + ' ' + gitLogEntriesRequested)
  //Get commits. these are updated when user scrolls to bottom
   GitLog(gitLogCommitsToRenderEachTime, gitLogEntriesRequested).then(commits => {
    //console.log('RECEIVED ' + commits)
    mainWindow.webContents.send('update-log-list', commits);
    gitLogEntriesCount -= gitLogCommitsToRenderEachTime
    gitLogEntriesRequested += gitLogCommitsToRenderEachTime
    console.log('remaining commits ' + gitLogEntriesCount)

  }).catch(error => {
    mainWindow.webContents.send('log', 'Error for git log ' + error, 'e');
  });
}

ipcMain.on('clicked-launch-difftool-btn', async (event, commitMessage: string) =>
{     
    
})

ipcMain.on('clicked-add-all-btn', async (event, commitMessage: string) =>
{     
    try
    {
      mainWindow.webContents.send('log',"Adding all changed files", 'i')
      await GitAddAllChanges();
      mainWindow.webContents.send('log',"-- Changed files added", 'i')
      Refresh();
    }catch(err)
    {
      mainWindow.webContents.send('log',"Error while staging files " + err, 'e');
    }
    
      
})

ipcMain.on('clicked-add-all-untracked-btn', async (event) =>
  {     
    try
    {
      mainWindow.webContents.send('log',"Adding all untracked files", 'i')
      await GitAddAllUntrackedFiles();
      mainWindow.webContents.send('log',"-- Untracked files added", 'i')
      Refresh();
    }
    catch(error)
    {
      mainWindow.webContents.send('log',"Error while adding files, git reported:\n" + error, 'e')
    }
        
  })

ipcMain.on('clicked-delete-all-btn', async (event) =>
  {     

    dialog.showMessageBox(mainWindow, {
      type: 'info', // Type of dialog (info, error, question, etc.)
      title: 'Alert',
      message: 'Are you sure you want to delete all files?',
      buttons: ['OK', 'Cancel'], // Button(s) to display
    }).then(async result => {
      if(result.response == 0)
      {
        try
        {
          mainWindow.webContents.send('log',"Deleting all untracked files", 'i')
          await GitDeleteAllUntrackedFiles();
          mainWindow.webContents.send('log',"-- Untracked files nuked", 'i')

          Refresh();
        }
        catch(error)
        {
         mainWindow.webContents.send('log',"Error while deleting files, git reported:\n" + error, 'e')
        }        
      }
      
    }).catch(err => {
    });
          
  })

ipcMain.on('clicked-difftool-file', async (event, fileName: string) =>
  {     
      try
      {
        await GitLaunchDifftoolOnOfile(fileName);
      }
      catch(error)
      {
        mainWindow.webContents.send('log',"Failed to launch difftool:\n" + error, 'e')

      }
     
  })

  ipcMain.on('clicked-delete-file', async (event, fileName: string) =>
    {     
      dialog.showMessageBox(mainWindow, {
        type: 'info', // Type of dialog (info, error, question, etc.)
        title: 'Alert',
        message: 'Are you sure you want to delete this file?',
        buttons: ['OK', 'Cancel'], // Button(s) to display
      }).then(async result => {
        if(result.response == 0)
        {
          try
          {
            mainWindow.webContents.send('log',"Deleting file " + fileName, 'i')
            await GitDeleteUntrackedFile(fileName);
            mainWindow.webContents.send('update-diff-area'," ") //Clear diff area
            mainWindow.webContents.send('log',"-- File nuked", 'i')

            Refresh();
          }
          catch(error)
          {
            mainWindow.webContents.send('log',"Error while deleting " + fileName, 'e')
            mainWindow.webContents.send('log',"-- Recommendation: manually delete the file", 'w')   
          }
          
        }
        
      }).catch(err => {
      });        
    })

ipcMain.on('clicked-discard-file-changes', async (event, fileName: string) =>
  {     
    dialog.showMessageBox(mainWindow, {
      type: 'info', // Type of dialog (info, error, question, etc.)
      title: 'Alert',
      message: 'Are you sure you want to discard changes to this file?',
      buttons: ['OK', 'Cancel'], // Button(s) to display
    }).then(async result => {
      if(result.response == 0)
      {
        await GitDiscardFileChanges(fileName);
        mainWindow.webContents.send('update-diff-area'," ") //Clear diff area
        Refresh();
      }
      
    }).catch(err => {
    });
        
  })

ipcMain.on('clicked-discard-all-btn', async (event, commitMessage: string) =>
{     
  dialog.showMessageBox(mainWindow, {
    type: 'info', // Type of dialog (info, error, question, etc.)
    title: 'Alert',
    message: 'Are you sure you want to discard all changes?',
    buttons: ['OK', 'Cancel'], // Button(s) to display
  }).then(async result => {
    if(result.response == 0)
    {
      await GitDiscardAllChanges();
      mainWindow.webContents.send('update-diff-area'," ") //Clear diff area
      Refresh();
    }
    
  }).catch(err => {
  });
   
})

ipcMain.on('clicked-add-file', async (event, filename: string) =>
  {     
    try{
      mainWindow.webContents.send('log',"Adding file to stage: " + filename, 'i')
      await GitStageFile(filename); 
      mainWindow.webContents.send('log',"-- File added", 'i')

      Refresh();
    }catch(error) {
      mainWindow.webContents.send('log',"Error while staging " + filename, 'e' + '\n' + error)
      mainWindow.webContents.send('log',"-- Recommendation: discard changes to this file", 'w')    
    }
  })

ipcMain.on('clicked-confirm-commit', async (event, commitMessage: string) =>
  {     
    event.reply('confirm-commit-response', 'close') //Tell the window to close
    try{
      mainWindow.webContents.send('log',"Commiting with message '" + commitMessage + "'", 'i')
      await GitCommitStaged(commitMessage); 
      mainWindow.webContents.send('log',"-- Commit ok", 'i')
      Refresh();
      RefreshCommitList();
    }catch(error) {
      mainWindow.webContents.send('log',"Error while commiting " + error, 'e')
      }    
  })

ipcMain.on('clicked-confirm-branch-name', async (event, branchName: string) =>
    {     

      event.reply('confirm-branch-name-response', 'close') //Tell the window to close
      try{
        mainWindow.webContents.send('log',"Creating branch " + branchName, 'i')
        await GitCreateBranch(branchName); 
        mainWindow.webContents.send('log',"-- Branch created ", 'i')
        Refresh();
        RefreshCommitList()
    }catch(error) {
        mainWindow.webContents.send('log',"Error while creating new branch: " + error, 'e')
    }    
})

ipcMain.on('clicked-confirm-origin-url', async (event, url: string) =>
  {     
    try
    {
      await GitSetOrigin(url);
      mainWindow.webContents.send('log',"Remote URL added: " + url, 'i')
    event.reply('confirm-url-response', 'close') //Tell the window to close

    }catch(err)
    {
      mainWindow.webContents.send('log',"Error while settign origin: " + err, 'e')
    }
  })

ipcMain.on('clicked-untracked-file', async (event, fileName: string)=>
  { 
    try{
      mainWindow.webContents.send('log',"Reading file " + fileName,'i')
      var content = await ReadFile(fileName); 
      mainWindow.webContents.send('log',"-- Reading file ok" ,'i')
      mainWindow.webContents.send('update-diff-area',content)
      

      Refresh();
    }catch(error) {
      mainWindow.webContents.send('log',error, 'w')    
    }
  })

ipcMain.on('clicked-staged-file', (event, fileName: string)=>
  { 
    try{
      mainWindow.webContents.send('log',"Unstaging file " + fileName,'i')
      GitUnstageFile(fileName); 
      mainWindow.webContents.send('log',"-- Unstaging file ok" ,'i')

      Refresh();
    }catch(error) {
      mainWindow.webContents.send('log',"Error while unstaging file " + error, 'e')
      
    }
  })

  ipcMain.on('clicked-commit-hash', (event, hash: string)=>
    { 
      try{
         dialog.showMessageBox(mainWindow, {
          type: 'info', 
          title: 'Alert',
          message: 'Are you sure you want to checkout this commit?',
          buttons: ['OK', 'Cancel'], 
        }).then(async result => {
          if(result.response == 0)
          {
            const match = hash.match(/^\b[0-9a-f]{40}\b/);
            var actualHash =  match ? match[0] : null;
            mainWindow.webContents.send('log',"Checking out commit " + actualHash,'i')
            await GitCheckoutBranch(actualHash)
            Refresh();
            mainWindow.webContents.send('log',"-- Check out ok",'i')

            return true;
          }
        }).catch(err => {
        });
        
  
        Refresh();
      }catch(error) {
        mainWindow.webContents.send('log',"Error while unstaging file " + error, 'e')
        
      }
    })

ipcMain.on('request-log-list', async (event, fileName: string)=>
  { 
    console.log('getting more git logs')
    if(gitLogEntriesCount > 0)
    {
      GitLog(gitLogCommitsToRenderEachTime, gitLogEntriesRequested).then(commits => {
        mainWindow.webContents.send('update-log-list', commits);
        gitLogEntriesCount -= gitLogCommitsToRenderEachTime
        gitLogEntriesRequested += gitLogCommitsToRenderEachTime
        console.log('remaining commits ' + gitLogEntriesCount)
  
      }).catch(error => {
        mainWindow.webContents.send('log', 'Error for git log ' + error, 'e');
      });
    }

  })


ipcMain.on('clicked-changed-file', async (event, fileName: string)=>
  {
    try{
     var res = await GitDiffFile(fileName); 
     mainWindow.webContents.send('update-diff-area',res)
     Refresh();
    }
    catch(error) {
      mainWindow.webContents.send('log',"Error while staging " + fileName, 'e')
      mainWindow.webContents.send('log',"\tRecommendation: discard changes to this file " + fileName, 'w')
    }
  })

  ipcMain.on('clicked-commit-btn', async (event, fileName: string)=>
    { 
      OpenCommitDialog(MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY)

    })

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);
// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

async function Refresh(){

  try
  {
    var name = await (await GitBranchName()).toString();
    if(name == 'HEAD')
      name = 'HEAD (detached)' //Adjustment for detached state
    mainWindow.webContents.send('update-branch-name',name)
  }
  catch(error)
  {
    mainWindow.webContents.send('update-branch-name','master')
    mainWindow.webContents.send('log','Looks like there are no commits, is this a fresh repo?', 'w')
  }

  try {

    GitStatusSB().then(status => {
      var tokens = status.split('\n')

      const regex = /\[(ahead \d+|behind \d+|ahead \d+, behind \d+)\]/;
      const match = tokens[0].match(regex);
      var status =  match ? match[1] : 'Up-to-date';
      var sub = tokens[0].substring(3)
      sub = sub.replace(/\[.*?\]/g, '').trim();
      mainWindow.webContents.send('update-branch-status', sub + ':-> ' + status);
      if(status.includes('ahead'))
        mainWindow.webContents.send('log', 'Your local branch is ahead, you should push your changes', 'w');
      else if(status.includes('behind'))
        mainWindow.webContents.send('log', 'Your local branch is behind, you should pull', 'w');


    }).catch(error => {
      mainWindow.webContents.send('log', 'Error for git status ' + error, 'e');
    });

    GitChangeList().then(changelist => {

      mainWindow.webContents.send('update-change-list', changelist);
    }).catch(error => {
     console.log('change error ' + error)

      mainWindow.webContents.send('log', 'Error for git change list ' + error, 'e');
    });
  
    GitUntrackedFiles().then(untracked => {
      mainWindow.webContents.send('update-untracked-list', untracked);
    }).catch(error => {
     console.log('change error ' + error)

      mainWindow.webContents.send('log', 'Error for git untracked files ' + error, 'e');
    });
  
    GitStagedList().then(staged => {
      mainWindow.webContents.send('update-staged-list', staged);
    }).catch(error => {
     console.log('change error ' + error)

      mainWindow.webContents.send('log', 'Error for git staged list ' + error, 'e');
    });
  

  } catch (error) {
    console.log('Refresh error ' + error)
    mainWindow.webContents.send('log', 'Unexpected error ' + error, 'e');
  }
  
}

///Pick folder to repo
async function openFolderPicker() {
  const result = await dialog.showOpenDialog(mainWindow, {
    properties: ['openDirectory'], // Allow only directory selection
  });

  if (!result.canceled) {
    const selectedFolderPath = result.filePaths[0]; // Get the selected folder path
    
    ChangeDir(selectedFolderPath)

    try{
      isValidRepo = true
      CreateMenu();

      //Start watcher
      chokiWathcer = chokidar.watch(selectedFolderPath, {
        persistent: true,
        ignored: /(^|[\/\\])\.(git|.gitlab|node_modules|ignored_folder)/,
        ignoreInitial: true, // Ignore initial add events
        usePolling: true, // Use polling instead of native events for better compatibility
        interval: 500, // Polling interval (in milliseconds)
        binaryInterval: 300, // Polling interval for binary files
        awaitWriteFinish: { // Wait for the file write to finish
            stabilityThreshold: 1000, // Wait for 1 second after a write
            pollInterval: 100 // Polling interval while waiting
        }
      });

      if(checkFilesTimeout !== null)
        clearTimeout(checkFilesTimeout)
      
      checkFilesTimeout = setTimeout(()=>{
        if(filesHaveChanged)
        {
          console.log('--- Refresh time!!!! --- ')
          Refresh();
          filesHaveChanged = false;
        }

      },500)

      chokiWathcer.on('all', (event: any, path: any) => {
        console.log("Refresh event: " + event + " path " + path)
        filesHaveChanged = true;
      
      });

      var title = await (await GitTopLevel()).toString();
      console.log('Recieved ' + typeof title)
      var tokens = title.split('\\')
      var name = tokens.at(tokens.length -1)
      mainWindow.webContents.send('update-title',name)


      //Update commit count
      await RefreshCommitList();
      
    }
    catch(error)
    {
      console.log('Error ' + error)
      dialog.showMessageBox(mainWindow, {
        type: 'info', // Type of dialog (info, error, question, etc.)
        title: 'Alert',
        message: 'This is not a valid git repo!',
        buttons: ['OK'], // Button(s) to display
      }).then(result => {
      }).catch(err => {
      });
    }

    Refresh();
    mainWindow.webContents.send('update-diff-area'," ") //Clear diff area

    // You can perform further actions with the selected folder here
  } else {
    console.log('Folder selection was canceled');
  }
}
//Handles, invoked by code in dialog html

ipcMain.handle('get-branch-list', (event, remote: boolean)=>
  { 
    try{
      
      return GitBranchList(remote)
    }catch(error) {
      mainWindow.webContents.send('log',"Error while fetching branch list " + error, 'e')
      
    }
  })

ipcMain.handle('checkout-branch', async (event, branchName: string, dialogWindow: Electron.BrowserWindow)=>
  { 
    try{
      await dialog.showMessageBox(dialogWindow, {
        type: 'info', // Type of dialog (info, error, question, etc.)
        title: 'Alert',
        message: 'Are you sure you want to switch branch?',
        buttons: ['OK', 'Cancel'], // Button(s) to display
      }).then(async result => {
        if(result.response == 0)
        {
          mainWindow.webContents.send('log',"Checking out branch " + branchName,'i')
          await GitCheckoutBranch(branchName)
          mainWindow.webContents.send('log',"-- Checking out ok " + branchName,'i')

          //Update commit count
          Refresh();
          RefreshCommitList();

          return true;
        }
      }).catch(err => {
      });
      
    }catch(error) {
      mainWindow.webContents.send('log',"Error while checking out branch " + error, 'e')
      return false;
    }
})

ipcMain.handle('checkout-track-branch', async (event, branchName: string, dialogWindow: Electron.BrowserWindow)=>
  { 
    try{
      await dialog.showMessageBox(dialogWindow, {
        type: 'info', // Type of dialog (info, error, question, etc.)
        title: 'Alert',
        message: 'Are you sure you want to track branch?',
        buttons: ['OK', 'Cancel'], // Button(s) to display
      }).then(async result => {
        if(result.response == 0)
        {
          mainWindow.webContents.send('log',"Checking out and tracking branch " + branchName,'i')
          await GitCheckoutTrackBranch(branchName)
          mainWindow.webContents.send('log',"-- Checking out ok " ,'i')

          

          return true;
        }
      }).catch(err => {
      });
      
    }catch(error) {
      mainWindow.webContents.send('log',"Error while checking out branch " + error, 'e')
      return false;
    }
})

ipcMain.handle('checkout-new-branch-from', async (event, branchName: string, dialogWindow: Electron.BrowserWindow)=>
  { 
    mainWindow.webContents.send('log',"New branch from " + branchName, 'e')
    SetBaseBranch(branchName)
    OpenBranchNameDialog(MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY)
    ResetBaseBranch()

})

ipcMain.handle('delete-local-branch', async (event, branchName: string, dialogWindow: Electron.BrowserWindow)=>
  { 
    try
    {
      mainWindow.webContents.send('log',"Deleting branch " + branchName,'i')
      await GitDeleteLocalBranch(branchName)
      mainWindow.webContents.send('log',"-- Branch deleted",'i')
      return true;
    }
    catch(error)
    {
        mainWindow.webContents.send('log',"Error while deleting branch " + error, 'e')
        return false;
    }
})

ipcMain.handle('merge-branch', async (event, branchName: string, dialogWindow: Electron.BrowserWindow)=>
  { 
    try
    {
      mainWindow.webContents.send('log',"Merging branch " + branchName,'i')
      await GitMergeBranch(branchName)
      mainWindow.webContents.send('log',"-- Merge done" , 'i')
      return true;
    }
    catch(error)
    {
        mainWindow.webContents.send('log',"Error while deleting branch " + error, 'e')
        return false;
    }
})